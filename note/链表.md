## 链表的结构

单链表:结点有一个指针域的链表
双链表:结点有两个指针域的链表，双向链表的本质就是空间换时间，因此如果题目对时间有要求，可以考虑使用双向链表，
循环链表:首尾相接的链表，当我们需要在遍历到尾部之后重新开始遍历的时候，可以考虑使用循环链表。

头指针:执行链表中第一个结点的指针。
首元结点:链表中存储第一个数据元素va1的结点。
头结点:链表首元结点之前的一个结点,往往不存储元素，作为附加结点。

**头结点**

1.如何表示空表?

无头结点,头指针为空时表示空表 head == null
有头结点,当头结点的指针域为空时表示空表 head.next == null

2.头结点的好处?

便于首元结点的处理
    首元节点的地址保存在头结点的指针域中，所以链表的第一个位置上的操作和其他位置一致，不需要进行特殊处理。
便于空表和非空表的统一处理
    
3.头结点的数据域内装什么？

可以为空，也可以存放线性表的长度等附加信息。但此结点在统计表长时不算入。

## 链表的基本操作

**链表节点的定义**

```JAVA
 public class ListNode {
      int val;
      ListNode next;
      ListNode() {}
      ListNode(int val) { this.val = val; }
      ListNode(int val, ListNode next) { this.val = val; this.next = next; }
```

**判断链表是否为空**

```JAVA
boolean ListEmpty(ListNode head){
    return head.next == null
}
```

**单链表的销毁**

从头指针开始，依次释放所有的结点，包括了头结点。

```
while(L){
    //需要辅助结点p，p指向要销毁的结点
    P = L;
    L = L.next ;
    //Java中有垃圾回收机制,p = null
    delete p ;
}   
```

**清空链表**

链表仍存在，但链表中无元素，成为空链表，头指针和头结点仍然在。

```
//P从首元结点开始
p = L.next;
while(p){
    //q指向要清除的结点的下一个结点
    q = p.next;
    delete p ;
    p = q;
}

```

**结点的取值**

```
//p指针用于寻找，从首元结点开始，count表示计数,i表示要找的第几个元素

p = L.next;
count = 1;
while(p && count < i){
    P = p.next;
    count ++ ;
}
```

**结点的插入**

这里往往需要先遍历找到结点

<img src="https://raw.githubusercontent.com/Rananie/imgs_rananie/master/algorithm/basic/%E8%8A%82%E7%82%B9%E7%9A%84%E6%8F%92%E5%85%A5.jpg?token=AHTYULGZZ5YRYNDVR4HFSI275LEC6">


**结点的删除**

只需要将需要删除的节点的前驱指针的 next 指针修正为其下下个节点即可，注意考虑边界条件。

伪代码：

```
待删除位置的前驱节点.next = 待删除位置的前驱节点.next.next
```

### 链表的遍历

**链表是一种兼具递归和迭代性质的数据结构**，树结构是链表的衍生，所以链表也有前序遍历和后序遍历。

```JAVA
void traverse(ListNode head){
    //前序遍历
    traverse(head.next);
    //后序遍历
}
```

**性能分析**

类型 | 插入/删除(时间复杂度) | 查询(时间复杂度) | 使用场景 
:-:|:-:|:-:|:-:
数组|O(n) | o(1) | 数据量固定、频繁查询、较少增删
链表|O(1) | O(n)  | 数据量不固定，频繁增删、较少查询



### 相交或环形链表

1.判断某条链表是否存在环。
2.获取某条链表环的大小。
3.获取某两条链表的相交节点。


#### 相交链表

**双指针法**

找到两个单链表相交的起始节点。

[如图所示](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)

这种题目的重点就是

A单独的部分 + AB共有的部分 + B单独的部分 = B单独的部分 + AB共有的部分 + A单独的部分

这样一定在交点处相遇。即使没有交点，去掉AB共有的部分，等式也是成立的。

**哈希法**

1.有 A, B 这两条链表, 先遍历其中一个，比如 A 链表, 并将 A 中的所有节点存入哈希表。
2.遍历 B 链表,检查节点是否在哈希表中, 第一个存在的就是相交节点

#### 环形链表

##### 判断是否有环

**思路**
可以使用快慢指针法， 分别定义 fast 和 slow指针，从头结点出发，fast指针每次移动两个节点，slow指针每次移动一个节点，如果 fast 和 slow指针在途中相遇 ，说明这个链表有环。

- 问题：为什么一定在环中相遇？
在非环的位置，fast一定走的比slow快，所以fast一定会先进入环，然后在环中循环。slow是一步一步走的，那么在环中一定会相遇。

##### 求环的起点

**哈希法**

遍历整个链表，如果当前的结点不在哈希表中则添加之后继续遍历，如果在哈希表中,那么当前的结点就是环的入口结点。

时间复杂度：O(N)
空间复杂度：O(N) 新建一个哈希表

**快慢指针法**

<img src="../img/leetcode/环形链表入口点.jpg">
