
## 综述

使用场景：解决连续问题，如"连续子串xxx","连续子数组xxx"。
优点：把嵌套的for循坏转换为单个for循坏，优化时间复杂度。

**滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。**

由于区间连续，因此当区间发生变化时，可以通过旧有的计算结果对搜索空间进行剪枝，这样便减少了重复计算，降低了时间复杂度。通常使用双指针法

假设有数组[a,b,c,d,e],一个大小为2的滑动窗口在其滑动，滑动窗口也可以说是在合法区间内滑动，动态的拥有一些数据。

```
[a,b]
    [b,c]
        [c,d]
            [d,e]
```

滑动窗口一般需要注意以下三个问题:
窗口内是什么？
如何移动窗口的起始位置？
如何移动窗口的结束位置？


## 滑动窗口的分类

- 固定窗口大小
- 窗口大小不固定，求解最大的满足条件的窗口
- 窗口大小不固定，求解最小的满足条件的窗口

**固定窗口大小**

对于固定窗口，我们只需要固定初始化左右指针left和right之间的距离。

1.left初始化为0。
2.初始化right，使 窗口大小 = right - left + 1。
3.同时移动left和right，固定住窗口的大小。
4.判断窗口内的连续元素是否满足题目限定的条件。
    4.1 如果满足，再判断是否需要更新最优解，如果需要则更新最优解。
    4.2 如果不满足，则继续。

**可变窗口大小**

对于可变窗口，同样固定初始化左右指针left和right,分别表示窗口的左右顶点。

1.left和right都初始化为0。
2.right指针移动一步
3.判断窗口内的连续元素是否满足题目限定的条件
    3.1 如果满足，再判断是否需要更新最优解，如果需要则更新最优解。并尝试通过移动 left 指针缩小窗口大小。循环执行 3.1
    3.2 如果不满足，则继续。

也就是说right指针先右移，直到窗口满足条件，然后移动left指针，缩小范围。

## 滑动窗口的模板

最短子串模板：1）外层循环遍历终点j ，2）内循环：如果当前窗口满足条件，和最最优比并保存，然后起点 i++

```
for (int j = 0; j < s.size(); j++) {
窗口右端扩展，加进s[j], 更新条件
while(满足条件) {
		和当前最优比较并保存
		窗口左端移除s[i]，更新条件，i++
	}
}
```

最长子串模板：当前窗口满足条件，1）外循环加进一个元素，2）内循环：如果破坏了invariant，窗口左指针不断推进以满足条件，3）内循环退出：满足条件，和最优比较并记录。

```
for (int j = 0; j < s.size(); j++) {
	窗口右端扩展，加进s[j], 更新条件
	while(不满足条件) {
		窗口左端移除s[i]，更新条件，然后i++
	}
	此时重新满足条件，和最优比较并记录
}
```

区别主要是：最短子串模板因为求最短，所以在窗口缩小的时候记录，最长子串模板是在窗口扩展时候记录

```JAVA
void slidingWindow(String s, String t){
 //创建Map对象
Map<String, String> window = new HashMap<String,String>(); 
Map<String, String> need = new HashMap<String,String>(); //暂时不知道有什么用
for(char c:t) map.put(key,map.getOrDefault(key,0)+1);//暂时不知道有什么用

int left=0,right=0;
int valid=0;
while(right<s.length()){
    //c是将要移入窗口的字符
    char c = s.charAt(right);
    //右移窗口
    right++;
    //进行窗口内数据的一系列更新
    ...
    //判断左窗口是否需要收缩
    while(window needs shrink){
    //d是将移除窗口的字符
    char d =s.charAt(left);
    //左移窗口
    left++;
    //进行窗口内从数据的一系列更新
    ...
    }
}

}

```


## 题目

- [x] 209.长度最小的子数组
- [x] 3.无重复字符的最长字串 
